### 一、定义
n个节点构成的有限集合

### 二、非空树的性质

（1）有一个根结点，r表示
（2）其余结点可分为若干集合，是子树三、树的数据结构表示
（3）满K叉树只能有度为0的结点和度为k的结点
儿子-兄弟表示法
每个节点有两个指针，一个指向其儿子，一个指向其同层的兄弟
静态链表表示法
利用结构体数组来表示，数组的每个元素存储左右子树的下标和该节点的字母
### 三、树的三种存储结构
孩子表示法：每个结点作为头结点，与其所有孩子串成单链表

孩子兄弟表示法（二叉链表表示法）：每个结点包括结点值，指向第一个孩子的指针，和指向结点下一个兄弟的指针

双亲表示法：一个数组，每个结点存其双亲的下标
### 四、二叉树

4.1特殊二叉树
（1）斜二叉树
（2）完美二叉树（满二叉树）
除子节点外其余任何节点都是二度
（3）完全二叉树

### 五、二叉树的重要性质

（1）第i层最多有2的i-1次方个节点
（2）深度为k的二叉树有最大结点总数2的k次方-1
（3）度为2的节点个数是叶节点数+1
(4)非满二叉树的完全二叉树，总结点数为偶数，叶子结点和非叶子结点对半分，总结点数为奇数，叶子结点比非叶结点数多一个
（5）哈夫曼树叶节点数比非叶节点数多一个
### 六、二叉树的抽象数据类型

操作集：
（1)创建一个二叉树
（2)判断二叉树是否为空
（3）遍历一个二叉树
前序遍历，中序遍历，后序遍历

### 七、二叉树的存储结构

==（1）数组顺序存储==

最适用于完全二叉树，按从上往下，从左往右的顺序标出序号存储

已知任何一个节点，都可以找出其父节点：  i/2向下取整 和 左子节点：2i 右子节点 2i+1
一般二叉树用数组存储会造成空间浪费
（2）链表链式存储

### 八、二叉树的遍历

（1）递归遍历，以先序为例

```c
void travel (bintree bt)
{
	if(bt)
    {print;
     travel(bt->left);
     travel(bt->right);

    }

}

```

中序和后序不过是换一下三个的位置
（2）非递归遍历：堆栈实现

中序:

```c
void inordertravel(bintree bt)
{
    stack s=creatstack(maxsize);
    bintree t=bt;
    while(t||!isempty(s))
    {
        while(t)
        {push(t,s);
         t=t->left;
			}
        if(!isempty(s))
        {
            t=pop(s);
            printf("%d",t->data);
            t=t->right;
            
        }
        
    }
    
    
    
}
```

前序:

```c
void inordertravel(bintree bt)
{
    stack s=creatstack(maxsize);
    bintree t=bt;
    while(t||!isempty(s))
    {
        while(t)
        {push(t,s);
         printf("%d",t->data);
         t=t->left;
			}
        if(!isempty(s))
        {
            t=pop(s);
            t=t->right;
            
        }
        
    }
    
    
    
}
```



后序:

（3）层序遍历：队列实现 

二叉树遍历的核心问题 ，访问左子节点后无法回到父节点，所以需要有一个存储结构保留暂时不访问的节点

### 九、二叉树遍历的应用

（1）求叶子节点的个数



（2）求树高

（3）二元运算表达式树

 (4)由中+前/后/层序遍历序列构造二叉树方法：根据前/后/层序序列找到根，再由中序从根划分为左子树中序序列和右子树中序序列

### 十、树的同构

（1）二叉树表示
